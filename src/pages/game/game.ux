<template>
  <scroll class="page" id="scroll" scroll-y="true">
    <!-- 顶部时间显示 -->
    <div class="header">
      <text class="title-text">{{ c.c1 || '08:00' }}</text>
      <input class="btn" value="≡" onclick="toggleMenu" />
    </div>

    <!-- 菜单系统 -->
    <div if="{{showMenu}}" class="menu-overlay" onclick="toggleMenu">
      <div class="menu-content" onclick="stopPropagation">
        <!-- 标签页导航 -->
        <div class="tabs">
          <div class="tab {{activeTab === 'status' ? 'active-tab' : ''}}" onclick="switchTab('status')">
            <text>状态</text>
          </div>
          <div class="tab {{activeTab === 'save' ? 'active-tab' : ''}}" onclick="switchTab('save')">
            <text>存档</text>
          </div>
          <div class="tab {{activeTab === 'settings' ? 'active-tab' : ''}}" onclick="switchTab('settings')">
            <text>设置</text>
          </div>
        </div>

        <!-- 状态标签页 -->
        <div if="{{activeTab === 'status'}}" class="tab-content">
          <div class="status-grid">
            <!-- A类变量（数值/字符串）-->
            <div class="category-section">
              <text class="category-title">普通变量</text>
              <div class="status-item" for="{{Object.keys(a)}}">
                <text class="status-label">{{getVarDesc('a', $item)}}:</text>
                <text class="status-value">{{getFormattedValue('a', $item)}}</text>
              </div>
            </div>

            <!-- B类变量（布尔值）-->
            <div class="category-section" if="{{Object.keys(b).length > 0}}">
              <text class="category-title">布尔变量</text>
              <div class="status-item" for="{{Object.keys(b)}}">
                <text class="status-label">{{getVarDesc('b', $item)}}:</text>
                <text class="status-value">{{b[$item]}}</text>
              </div>
            </div>

            <!-- C类变量（特殊值）-->
            <div class="category-section">
              <text class="category-title">时间变量</text>
              <div class="status-item" for="{{Object.keys(c)}}">
                <text class="status-label">{{getVarDesc('c', $item)}}:</text>
                <text class="status-value">{{c[$item]}}</text>
              </div>
            </div>
          </div>
        </div>

        <!-- 存档标签页 -->

        <div if="{{activeTab === 'save'}}" class="tab-content">
          <div class="save-grid">
            <div class="save-item" for="{{item in saveSlots}}">
              <div class="save-header">
                <text class="save-title">存档{{$idx + 1}}</text>
                <text class="save-time">{{item.time || '暂无存档'}}</text>
              </div>
              <div class="save-buttons">
                <text class="save-btn" onclick="saveToSlot($idx)">保存</text>
                <text class="load-btn" onclick="loadFromSlot($idx)">加载</text>
                <text class="delete-btn" onclick="deleteSaveSlot($idx)">删除</text>
              </div>
            </div>
          </div>
        </div>

        <!-- 设置标签页 -->
        <div if="{{activeTab === 'settings'}}" class="tab-content">
          <div class="setting-item">
            <text class="menu-font">调试模式</text>
            <switch checked="{{debugMode}}" onchange="toggleDebugMode" style="color:#4a90e2;" />
          </div>
          <div class="menu-btn" onclick="backToHome">
            <text class="menu-font">返回主菜单</text>
          </div>
        </div>
      </div>
    </div>
    <!-- 内容区域 -->
    <div class="scene">
      <block for="{{segments}}">
        <!-- 文本片段 -->
        <text if="$item.type === 'text'" class="normal-text">{{$item.content}}</text>

        <!-- 变量显示 -->
        <text if="$item.type === 'var'" class="var-text">{{$item.content}}</text>

        <!-- 可点击链接 -->
        <text if="$item.type === 'link'" class="link-text"
          onclick="selectOption($item.linkIndex)">{{$item.content}}</text>

        <!-- 禁用链接 -->
        <text if="$item.type === 'disabled'" class="disabled-text">{{$item.content}}</text>
            <image 
              src="{{$item.path}}" 
              style="width:{{$item.width}}px"
              data-index="{{$idx}}" 
              onerror="handleImageError"
            />
            <text if="$item.type === 'error'" class="error-text">[ERR] {{$item.content}}</text>
<text if="$item.type === 'error'" class="error-text">[ERR] {{$item.content}}</text>
      </block>
    </div>
  </scroll>
</template>

<script>
import router from "@system.router"
import storage from "@system.storage"
import prompt from "@system.prompt"
import gameData from '../../common/game-data.json'

export default {
  private: {
    debugMode: true,
    timer: null,
    showMenu: false,
    activeTab: 'status',
    saveSlots: [{ time: "" }, { time: "" }, { time: "" }],
    currentNodeId: "index",
    segments: [],
    currentLinks: [],
    STORAGE_KEY: "game_state",
    
    // 变量系统
    vars: {}
  },

  onInit() {
    this.initVariableSystem();
    this.loadNode(this.currentNodeId);
    this.loadSaveSlots();
    
    this.debugLog("游戏初始化完成");
  },
  
  onDestroy() {
    clearInterval(this.timer);
  },

  // ================= 调试工具 =================
  debugLog(message, data = null) {
    if (this.debugMode) {
      console.info(message, data);
      
      // 使用prompt显示重要日志
      if (message.length < 50) {
        prompt.showToast({
          message: `DEBUG: ${message}`,
          duration: 100
        });
      }
    }
  },

  // ================= 变量系统 =================
  initVariableSystem() {
    this.vars = JSON.parse(JSON.stringify(gameData.variables || {}));
    this.debugLog("变量系统初始化");
  },
  
  getVariable(path) {
    if (!path.startsWith('var.')) {
      this.debugLog(`无效变量路径: ${path}`);
      return undefined;
    }
    
    const realPath = path.substring(4);
    const parts = realPath.split('.');
    let current = this.vars;
    
    for (const part of parts) {
      if (current && current[part] !== undefined) {
        current = current[part];
      } else {
        return undefined;
      }
    }
    
    // 返回实际值而不是对象
    return current;
  },
  
  setVariable(path, value) {
    if (!path.startsWith('var.')) {
      this.debugLog(`无效变量路径: ${path}`);
      return;
    }
    
    const realPath = path.substring(4);
    const parts = realPath.split('.');
    let current = this.vars;
    
    for (let i = 0; i < parts.length - 1; i++) {
      const part = parts[i];
      if (!current[part]) {
        current[part] = {};
      }
      current = current[part];
    }
    
    const lastKey = parts[parts.length - 1];
    current[lastKey] = value;
    
    this.debugLog(`变量设置: ${path} = ${value}`);
  },

  // ================= 节点引擎 =================
  loadNode(nodeId) {
    try {
      const node = gameData.nodes[nodeId];
      if (!node) {
        throw new Error(`节点 ${nodeId} 未找到`);
      }
      
      // 执行节点动作
      this.executeActions(node.actions || []);
      
      // 更新当前节点状态
      this.currentNodeId = nodeId;
      this.currentLinks = node.links || [];
      
      // 解析节点文本
      this.parseTextWithLinks(node.text);
      
      this.debugLog(`加载节点: ${nodeId}`, {
        links: this.currentLinks.length
      });
      
    } catch (e) {
    console.error("节点加载错误:", e);
    this.pushErrorSegment(`节点加载错误: ${e.message}`); // 修改点
    prompt.showToast({
      message: `节点错误: ${e.message}`,
      duration: 3000
    });
  }
  },
  
  parseTextWithLinks(text) {
    this.segments = [];
    if (!text) return;
    
    let lastPosition = 0;
    const regex = /\{(\w+\.?[\w\.]*)\}/g;
    let match;
    
    while ((match = regex.exec(text)) !== null) {
      if (match.index > lastPosition) {
        this.segments.push({
          type: "text", 
          content: text.substring(lastPosition, match.index)
        });
      }
      
      const marker = match[1];
      
      // 处理链接标记（数字索引）
      if (/^\d+$/.test(marker)) {
        this.handleLinkMarker(parseInt(marker));
      } 
      else if (marker.startsWith('img')) {
        this.handleImageMarker(marker);
      }
      else if (marker.startsWith('var.')) {
        this.handleVariableMarker(marker);
      }
      else if (marker.startsWith('random')) {
        this.handleRandomMarker(marker);
      }
      else if (marker.startsWith('cond')) {
        this.handleConditionMarker(marker);
      }
      else if (marker.startsWith('js.')) {
        this.handleScriptMarker(marker);
      }
      else {
        this.segments.push({ 
          type: "text", 
          content: `{${marker}}` 
        });
      }
      
      lastPosition = match.index + match[0].length;
    }
    
    if (lastPosition < text.length) {
      this.segments.push({ 
        type: "text", 
        content: text.substring(lastPosition) 
      });
    }
  },
  
  // ================= 标记处理器 =================
  handleLinkMarker(linkIndex) {
    // 链接索引从0开始处理
    if (linkIndex >= 0 && linkIndex < this.currentLinks.length) {
      const link = this.currentLinks[linkIndex];
      
      if (this.checkCondition(link.condition)) {
        this.segments.push({ 
          type: "link", 
          content: link.text, 
          linkIndex 
        });
      } else {
        this.segments.push({ 
          type: "disabled", 
          content: link.text 
        });
      }
    } else {
    this.pushErrorSegment(`无效链接${linkIndex}`); // 修改点
  }
  },
  
  handleImageMarker(markerId) {
  const imgId = markerId.replace('img.', '');
  
  // 防御性检查
  const currentNode = gameData.nodes[this.currentNodeId];
  if (!currentNode) {
    this.pushErrorSegment(`当前节点未定义: ${this.currentNodeId}`);
    return;
  }
  
  if (!currentNode.imgs || !currentNode.imgs[imgId]) {
    this.pushErrorSegment(`图片配置错误: ${imgId}`);
    return;
  }

  const imgDef = currentNode.imgs[imgId];
  let path = imgDef.path || '';
  
  // 统一替换逻辑 - 只处理${expr}格式
  if (path.includes('${')) {
    try {
      path = path.replace(/\${(.*?)}/g, (_, expr) => {
        try {
          return this.parseExpression(expr)?.toString() || '';
        } catch(e) {
          this.debugLog(`表达式执行失败: ${expr}`, e);
          return 'ERROR';
        }
      });
    } catch(e) {
      this.pushErrorSegment(`图片路径表达式错误: ${imgId}`);
      return;
    }
  }
  
  // 调试输出原始路径
  this.debugLog(`原始图片路径: ${path}`, {imgId});
  
  // 增强路径标准化
  let finalPath = path;
  if (path) {
    // 已包含基础路径的情况
    const hasBasePath = path.includes('/common/images/');
    
    if (!hasBasePath && 
        !path.startsWith('/') && 
        !path.startsWith('http') && 
        !path.startsWith('.')) {
      finalPath = '/common/images/' + path;
    }
  } else {
    this.pushErrorSegment(`图片路径为空: ${imgId}`);
    return;
  }
  
  // 调试输出最终路径
  this.debugLog(`最终图片路径: ${finalPath}`, {imgId});
  
  // 创建图片段
  this.segments.push({
    type: "image",
    path: finalPath,
    width: imgDef.width || 150 // 默认宽度
  });
},

// 统一错误处理方法
pushErrorSegment(message) {
  this.segments.push({
    type: "error",
    content: message
  });
},

// 图片加载错误处理
handleImageError(e) {
  const index = parseInt(e.target.dataset.index);
  if (isNaN(index)) {
    this.debugLog("图片错误索引无效");
    return;
  }
  
  const segment = this.segments[index];
  if (segment?.type === "image") {
    this.pushErrorSegment(`图片加载失败: ${segment.path}`);
    this.$page.$forceUpdate();
    
    // 调试日志
    this.debugLog("图片加载错误详情", {
      path: segment.path,
      index: index
    });
  }
},
  
  handleVariableMarker(path) {
  // 检测是否为表达式 (含运算符)
  if (/[+\-*/><=?:]/.test(path)) {
    try {
      const result = this.parseExpression(path);
      this.segments.push({ type: "var", content: result });
    } catch(e) {
      this.pushErrorSegment(`表达式错误: ${path}`);
    }
  } 
  // 普通变量
  else {
    const value = this.getVariable(path);
    if (value !== undefined) {
      this.segments.push({ type: "var", content: value.toString() });
    } else {
      this.pushErrorSegment(`变量 ${path} 未定义`); 
    }
  }
},
  
handleRandomMarker(markerId) {
  // 提取实际随机组ID (去掉"random."前缀)
  const randomId = markerId.replace('random.', '');
  
  try {
    // 防御性检查1：节点是否定义随机组
    if (!gameData.nodes[this.currentNodeId]?.randoms) {
      this.pushErrorSegment(`节点未定义随机组`);
      return;
    }

    // 防御性检查2：特定随机组是否存在
    const options = gameData.nodes[this.currentNodeId].randoms[randomId];
    if (!options || !Array.isArray(options)) {
      this.pushErrorSegment(`随机组[${randomId}]未定义`, 'config');
      return;
    }

    // 检查空数组
    if (options.length === 0) {
      this.segments.push({ type: "text", content: "[无随机选项]" });
      return;
    }

    // 筛选有效选项（满足条件的）
    const validOptions = options.filter(opt => {
      if (opt.condition) {
        try {
          return this.checkCondition(opt.condition);
        } catch(e) {
          this.debugLog(`随机条件解析错误: ${opt.condition}`, e);
          return false;
        }
      }
      return true;
    });

    // 处理无有效选项情况
    if (validOptions.length === 0) {
      this.segments.push({ type: "text", content: "[无可用随机选项]" });
      return;
    }

    // 计算安全权重
    const weightedOptions = validOptions.map(opt => {
      let weight = opt.weight !== undefined ? opt.weight : 1;
      
      // 动态权重处理
      if (typeof weight === 'string') {
        try {
          weight = this.parseExpression(weight) || 0;
        } catch(e) {
          weight = 0;
        }
      }
      
      // 确保权重合法
      weight = typeof weight === 'number' 
        ? Math.max(0, weight) // 非负
        : 0;
        
      return { ...opt, weight };
    });

    // 计算总权重
    const totalWeight = weightedOptions.reduce((sum, o) => sum + o.weight, 0);
    
    // 处理全零权重情况
    if (totalWeight <= 0) {
      const fallbackText = weightedOptions[0]?.text || "[权重配置错误]";
      this.segments.push({ type: "text", content: fallbackText });
      return;
    }

    // 执行随机选择
    let randomVal = Math.random() * totalWeight;
    for (const opt of weightedOptions) {
      randomVal -= opt.weight;
      if (randomVal <= 0) {
        this.segments.push({ type: "text", content: opt.text });
        return;
      }
    }
    
    // 保底逻辑
    this.segments.push({ 
      type: "text", 
      content: weightedOptions[weightedOptions.length - 1].text 
    });

  } catch (e) {
    this.pushErrorSegment(`随机组处理失败: ${e.message}`);
  }
},
  
  handleConditionMarker(marker) {
  // 支持 cond.xxx 格式
  const conditionId = marker.replace('cond.', '');
  const conditions = gameData.nodes[this.currentNodeId]?.conds?.[conditionId];
  
  if (!conditions || !Array.isArray(conditions)) {
    this.pushErrorSegment(`条件组${marker}未定义`); 
    return;
  }
  
  let result = "[无匹配条件]";
  for (const cond of conditions) {
    if (!cond.condition || this.checkCondition(cond.condition)) {
      result = cond.text;
      break;
    }
  }
  
  this.segments.push({ 
    type: "text", 
    content: result 
  });
},

// 新增脚本处理器
handleScriptMarker(marker) {
  const scriptId = marker.replace('js.', '');
  const script = gameData.nodes[this.currentNodeId]?.scripts?.[scriptId];
  
  if (!script) {
    this.pushErrorSegment(`JS未定义: ${scriptId}`);
    return;
  }

  // 安全沙箱配置
  const sandbox = {
    // 安全API
    set: (path, val) => this.setVariable(`var.${path}`, val),
    get: (path) => this.getVariable(`var.${path}`),
    rand: (min, max) => Math.floor(Math.random() * (max - min + 1)) + min,
    print: (msg) => this.debugLog(`[JS] ${msg}`),
    
    // 受限环境
    Math: Math,
    Date: Date,
    JSON: JSON,
    Number: Number,
    String: String,
    Boolean: Boolean,
    
    // 禁止危险API
    eval: undefined,
    Function: undefined,
    setTimeout: undefined,
    setInterval: undefined,
    XMLHttpRequest: undefined,
    fetch: undefined
  };

  try {
    // 创建安全执行环境
    const safeScript = `(function(env) {
      with(env) { 
        try { 
          ${script} 
        } catch(e) { 
          print('执行错误: ' + e.message) 
        }
      }
    })`;
    
    const fn = new Function('return ' + safeScript)();
    fn(sandbox);
  } catch(e) {
    this.debugLog(`JS编译错误: ${scriptId}`, e);
  }
},
  
  // ================= 操作执行器 =================
  executeActions(actions = []) {
  actions.forEach(action => {
    try {
      switch (action.type) {
        case "set":
          this.setVariable(action.target, 
            typeof action.value === 'string' 
              ? this.parseExpression(action.value) 
              : action.value
          );
          break;
          
        case "add":
          const currentAdd = this.getVariable(action.target) || 0;
          const addValue = typeof action.value === 'string' 
            ? this.parseExpression(action.value) 
            : action.value;
          this.setVariable(action.target, currentAdd + addValue);
          break;
          
        case "toggle":
          const currentBool = this.getVariable(action.target) || false;
          this.setVariable(action.target, !currentBool);
          break;
          
        case "random":
          const validChoices = action.choices.filter(c => 
            !c.if || this.checkCondition(c.if)
          );
          
          if (validChoices.length > 0) {
            const totalWeight = validChoices.reduce((sum, c) => 
              sum + (c.weight || 1), 0);
            let randVal = Math.random() * totalWeight;
            
            for (const choice of validChoices) {
              randVal -= choice.weight || 1;
              if (randVal <= 0) {
                this.executeActions(choice.actions || []);
                break;
              }
            }
          }
          break;
      }
    } catch (e) {
      this.debugLog(`操作执行失败: ${JSON.stringify(action)}`, e);
    }
  });
},
  
  // ================= 条件检查 =================
  checkCondition(condition) {
  if (!condition) return true;
  
  // 处理括号分组
  const groupRegex = /\((.*?)\)/g;
  while (groupRegex.test(condition)) {
    condition = condition.replace(groupRegex, (_, group) => 
      this.checkCondition(group) ? 'true' : 'false'
    );
  }
  
  // 逻辑运算符处理
  const andParts = condition.split('&&').map(s => s.trim());
  if (andParts.length > 1) {
    return andParts.every(part => this.checkCondition(part));
  }

  const orParts = condition.split('||').map(s => s.trim());
  if (orParts.length > 1) {
    return orParts.some(part => this.checkCondition(part));
  }

  // 单条件解析 (支持字符串/数值/布尔比较)
  const match = condition.match(
    /(var\.\w+(\.\w+)*)\s*(==|!=|>|<|>=|<=)\s*(['"](.*?)['"]|(\d+\.?\d*)|true|false)/
  );

  if (match) {
    const [, leftPath, , operator, , strValue, numValue] = match;
    let leftVal = this.getVariable(leftPath);
    
    // 确定右值
    let rightVal;
    if (strValue !== undefined) {
      rightVal = strValue;
    } else if (numValue !== undefined) {
      rightVal = parseFloat(numValue);
    } else if (match[0].includes('true')) {
      rightVal = true;
    } else if (match[0].includes('false')) {
      rightVal = false;
    } else {
      return false;
    }

    // 自动类型转换
    if (typeof leftVal === 'string' && !isNaN(rightVal)) {
      leftVal = parseFloat(leftVal);
    } else if (typeof rightVal === 'string' && !isNaN(leftVal)) {
      rightVal = parseFloat(rightVal);
    }

    // 比较操作
    switch(operator) {
      case '==': return leftVal == rightVal;
      case '!=': return leftVal != rightVal;
      case '>': return leftVal > rightVal;
      case '<': return leftVal < rightVal;
      case '>=': return leftVal >= rightVal;
      case '<=': return leftVal <= rightVal;
    }
  }
  
  // 布尔值直接判断
  if (condition === 'true') return true;
  if (condition === 'false') return false;
  
  // 纯变量存在判断
  if (condition.startsWith('var.')) {
    const val = this.getVariable(condition);
    return val !== undefined && val !== false && val !== 0;
  }
  
  return false;
},
  
  // ================= 存档系统 =================
  saveGameState() {
    const state = {
      vars: JSON.parse(JSON.stringify(this.vars)),
      currentNodeId: this.currentNodeId
    };
    
    storage.set({
      key: this.STORAGE_KEY,
      value: JSON.stringify(state),
      success: () => {
        this.debugLog("游戏状态已保存");
      },
      fail: (data, code) => {
        this.debugLog(`保存失败: code=${code}`);
      }
    });
  },
  
  loadSaveSlots() {
    [0, 1, 2].forEach(slotIndex => {
      storage.get({
        key: `save_slot_${slotIndex}`,
        success: (data) => {
          if (data) {
            try {
              const saveData = JSON.parse(data);
              this.saveSlots[slotIndex].time = saveData.time;
            } catch(e) {
              this.saveSlots[slotIndex].time = "损坏存档";
            }
          }
        }
      });
    });
  },
  
  saveToSlot(slotIndex) {
    const saveData = {
      time: this.getCurrentTime(),
      state: {
        vars: JSON.parse(JSON.stringify(this.vars)),
        currentNodeId: this.currentNodeId
      }
    };
    
    storage.set({
      key: `save_slot_${slotIndex}`,
      value: JSON.stringify(saveData),
      success: () => {
        this.saveSlots[slotIndex] = saveData;
        prompt.showToast({ 
          message: `存档${slotIndex+1}成功`,
          duration: 1000
        });
      },
      fail: () => {
        prompt.showToast({ 
          message: "存档失败",
          duration: 1000
        });
      }
    });
  },
  
  loadFromSlot(slotIndex) {
    storage.get({
      key: `save_slot_${slotIndex}`,
      success: (data) => {
        if (data) {
          try {
            const saveData = JSON.parse(data);
            
            // 恢复状态
            this.vars = saveData.state.vars;
            this.currentNodeId = saveData.state.currentNodeId;
            
            this.loadNode(this.currentNodeId);
            prompt.showToast({ 
              message: `加载存档${slotIndex+1}成功`,
              duration: 1000
            });
          } catch(e) {
            prompt.showToast({ 
              message: "存档损坏",
              duration: 1500
            });
          }
        } else {
          prompt.showToast({ 
            message: "无存档数据",
            duration: 1000
          }); 
        }
        this.showMenu = false;
      },
      fail: () => {
        prompt.showToast({ 
          message: "加载失败",
          duration: 1000
        });
        this.showMenu = false;
      }
    });
  },
  
  deleteSaveSlot(slotIndex) {
    storage.delete({
      key: `save_slot_${slotIndex}`,
      success: () => {
        this.saveSlots[slotIndex].time = "";
        prompt.showToast({ 
          message: `删除存档${slotIndex+1}成功`,
          duration: 1000
        });
      },
      fail: () => {
        prompt.showToast({ 
          message: "删除失败",
          duration: 1000
        });
      }
    });
  },

  // ================= UI交互 =================
selectOption(linkIndex) {
  if (linkIndex >= 0 && linkIndex < this.currentLinks.length) {
    const link = this.currentLinks[linkIndex];
    
    // 执行链接动作
    this.executeActions(link.actions || []);
    
    // 确定目标节点
    let targetNode = link.target;
    
    // 随机目标处理
    if (link.random && link.random.length > 0) {
      const validOptions = link.random.filter(opt => 
        !opt.if || this.checkCondition(opt.if)
      );
      
      if (validOptions.length > 0) {
        const totalWeight = validOptions.reduce((sum, o) => sum + o.weight, 0);
        let randVal = Math.random() * totalWeight;
        
        for (const opt of validOptions) {
          randVal -= opt.weight;
          if (randVal <= 0) {
            targetNode = opt.target;
            // 处理传入数据
            if (opt.incom) this.processIncomingData(opt.incom);
            break;
          }
        }
      }
    }
    
    // 处理传入数据
    if (link.incom) this.processIncomingData(link.incom);
    
    // 延迟加载新节点
    this.timer = setTimeout(() => {
      this.debugLog(`选择链接: ${linkIndex} -> ${targetNode}`);
      this.loadNode(targetNode);
    }, 150);
  }
},

handleImageTap(e) {
      const index = e.target.dataset.index;
      const segment = this.segments[index];
      this.$emit('imageTap', {
        path: segment.path,
        id: segment.imgId
      });
    },
    
  

processIncomingData(data) {
  Object.entries(data).forEach(([key, value]) => {
    // 解析表达式值
    if (typeof value === 'string' && /[+\-*/><=]/.test(value)) {
      try {
        const computed = this.parseExpression(value);
        this.setVariable(`var.temp.${key}`, computed);
      } catch(e) {
        this.setVariable(`var.temp.${key}`, value);
      }
    } else {
      this.setVariable(`var.temp.${key}`, value);
    }
  });
},

  toggleMenu() {
    this.showMenu = !this.showMenu;
    if (this.showMenu) {
      this.activeTab = 'status';
      this.loadSaveSlots();
    }
  },
  
  switchTab(tabName) {
    this.activeTab = tabName;
  },
  
  backToHome() {
    router.replace({ uri: "pages/index" });
  },
  
  toggleDebugMode(e) {
    this.debugMode = e.checked;
    prompt.showToast({ 
      message: `调试模式 ${e.checked ? '开启' : '关闭'}`,
      duration: 1000
    });
  },
  
  // ================= 工具方法 =================
  getCurrentTime() {
    const now = new Date();
    return `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
  },
  
  getCurrentDateTime() {
    const now = new Date();
    return `${now.getFullYear()}-${(now.getMonth()+1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')} ${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
  },
  pushErrorSegment(message, type = 'error') {
  this.segments.push({
    type: "error",
    content: message,
    errorClass: `error-type-${type}`  // 改为errorClass
  });
},
parseExpression(expr) {
  // 直接变量访问器
  const getVar = (path) => {
    const fullPath = `var.${path}`;
    const val = this.getVariable(fullPath);
    return val !== undefined ? val : 0;
  };

  try {
    // 替换变量引用格式
    const jsExpr = expr.replace(/var\.([\w.]+)/g, (_, p) => {
      return `getVar('${p}')`;
    });

    // 直接执行表达式
    return eval(jsExpr);
  } catch(e) {
    console.error(`表达式错误: ${expr}`, e);
    return 0;
  }
},
handleImageError(e, index) {
  this.$set(`segments[${index}]`, 'showFallback', true);
}
}
</script>

<style>
@import url(../../common/comm.css);

.header {
  width: 100%;
  justify-content: space-between;
  margin-bottom: 20px;
}

/* 菜单容器 - 小尺寸 */
.menu-overlay {
  width: 100%;
  height: auto;
  justify-content: center;
  align-items: center;
  color: #fff
}

.menu-content {
  width: 100%;
  background-color: #1a1a1a;
  flex-direction: column;
}

.menu-font {
  font-size: 30px;
}

/* 标签页样式 */
.tabs {
  flex-direction: row;
  justify-content: space-around;
  margin-bottom: 15px;
  border-bottom: 1px solid #333;
}

.tab {
  flex: 1;
  justify-content: center;
  align-items: center;
  background-color: #222222;
  font-size: 25px;
  color: #4a90e2;
}

.active-tab {
  background-color: #2a2a2a;
}

.tab-content {
  flex-direction: column;
}

/* 状态网格 */
.status-grid {
  flex-direction: column;
}

/* 调整状态项布局 */
.status-item {
  flex-direction: row;
  justify-content: space-between;
  margin-bottom: 8px;
}

.status-label {
  font-size: 28px;
  color: #cccccc;
}

.status-value {
  font-size: 28px;
  color: #ffffff;
  font-weight: bold;
}

.category-section {
  flex-direction: column;
}

.category-title {
  font-size: 32px;
  color: #4a90e2;
  margin: 15px 0 10px 0;
  border-bottom: 1px solid #333;
  padding-bottom: 5px;
}

/* 存档网格 */
.save-grid {
  flex-direction: column;
  margin-bottom: 8px;
}

.save-item {
  flex-direction: row;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
  padding: 8px 0;
  border-bottom: 1px solid #333;
}

/* 按钮样式 */
.menu-btn {
  height: 40px;
  background-color: #e74c3c;
  border-radius: 8px;
  justify-content: center;
  align-items: center;
  margin-top: 15px;
}

/* 设置项 */
.setting-item {
  flex-direction: row;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 15px;
  padding-bottom: 10px;
  border-bottom: 1px solid #333;
}


.save-title {
  color: #ffffff;
  font-size: 30px;
}

.save-time {
  color: #999999;
  font-size: 25px;
}

/* 新增按钮样式 */
.save-buttons {
  flex-direction: row;
  justify-content: space-between;
}

.save-btn {
  color: #4a90e2;
  padding: 5px 10px;
  border: 1px solid #4a90e2;
}

.load-btn {
  color: #2ecc71;
  padding: 5px 10px;
  border: 1px solid #2ecc71;
}

.delete-btn {
  color: #e74c3c;
  padding: 5px 10px;
  border: 1px solid #e74c3c;
}

/* 原保存/加载网格调整 */
.save-grid {
  flex-direction: column;
  gap: 15px;
}

.save-item {
  flex-direction: column;
  padding: 10px;
  border-bottom: 1px solid #333;
}

.btn {
  height: 60px;
  width: 120px;
  font-size: 50px;
  background-color: transparent;
  border: none;
}

.scene {
  width: 100%;
  padding: 10px;
  background-color: #1a1a1a;
  border-radius: 12px;
  flex-direction: row;
  flex-wrap: wrap;
}

/* 文本样式 */
.normal-text {
  font-size: 35px;
  color: #ffffff;
}

.var-text {
  font-size: 35px;
  color: #ffcc00;
}

.link-text {
  font-size: 35px;
  color: #4a90e2;
  text-decoration: underline;
}

.disabled-text {
  font-size: 35px;
  color: #777777;
  text-decoration: line-through;
}

/* 错误文本样式 */
.error-text {
  color: #ff4d4f;
  font-size: 35px;
}
