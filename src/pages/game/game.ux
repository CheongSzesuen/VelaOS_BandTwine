<template>
  <!-- 主容器 -->
  <div class="main-container">
    <!-- 独立侧边栏菜单 -->
    <div if="{{showMenu}}" class="sidebar-menu">
      <div class="menu-header">
        <text class="menu-title" onclick="toggleMenu">菜单</text>
      </div>

      <!-- 标签页导航 -->
      <div class="menu-tabs">
        <text class="menu-tab {{activeTab === 'status' ? 'active-tab' : ''}}" onclick="switchTab('status')">
          状态
        </text>
        <text class="menu-tab {{activeTab === 'save' ? 'active-tab' : ''}}" onclick="switchTab('save')">
          存档
        </text>
        <text class="menu-tab {{activeTab === 'settings' ? 'active-tab' : ''}}" onclick="switchTab('settings')">
          设置
        </text>
      </div>

      <!-- 标签页内容容器 -->
      <div class="tab-content-container">
        <!-- 状态标签页 -->
        <scroll if="{{activeTab === 'status'}}" class="menu-scroll" scroll-y="true">
          <div class="status-section" for="{{showVars}}">
            <text class="status-label">{{ $item.desc }}:</text>
            <text class="status-value">{{ $item.value }}</text>
          </div>
        </scroll>

        <!-- 存档标签页 -->
        <scroll if="{{activeTab === 'save'}}" class="menu-scroll" scroll-y="true">
          <div class="save-section">
            <div class="save-item" for="{{item in saveSlots}}">
              <div class="save-header">
                <div style="flex-direction: row; justify-content: space-between">
                  <text class="save-title">存档{{ $idx + 1 }}</text>
                  <text class="delete-btn" onclick="deleteSaveSlot($idx)">
                    删除
                  </text>
                </div>
                <div class="save-time">
                  <text class="save-date">
                    {{ item.time ? item.time.split(" ")[0] : "暂无存档" }}
                  </text>
                  <text class="save-time-part">
                    {{ item.time ? item.time.split(" ")[1] : "" }}
                  </text>
                </div>
              </div>

              <div class="save-actions">
                <text class="save-btn" onclick="saveToSlot($idx)">保存</text>
                <text class="load-btn" onclick="loadFromSlot($idx)">加载</text>
              </div>
            </div>
          </div>
        </scroll>

        <!-- 设置标签页 -->
        <div if="{{activeTab === 'settings'}}" class="settings-section">
          <div class="setting-item">
            <text style="font-size: 24px; color: #fff">调试</text>
            <switch checked="{{debugMode}}" style="height: 30px" onchange="toggleDebugMode" />
          </div>
          <div class="menu-action" onclick="backToHome">
            <text style="
								font-size: 24px;
								border-radius: 5px;
								background-color: #e74c3c;
								color: #fff;
							">
              返回主菜单
            </text>
          </div>
        </div>
      </div>
    </div>
    <!-- 内容滚动区域 -->
    <scroll id="scrollId" class="content-scroll" scroll-y="true">
      <!-- 顶部区域 -->
      <!-- 感谢wuhaiqi提供的弧形时间-->
      <div class="header" style="width: 212px; position: absolute; left: 0; top: 0; height: 35px" @click="toggleMenu">
        <text class="time" style="left: 60.9px; top: 3.8px; transform: rotate(-21deg)">
          {{ time[0] }}
        </text>
        <text class="time" style="left: 79px; top: -1px; transform: rotate(-9deg)">
          {{ time[1] }}
        </text>
        <text class="time" style="left: 93.5px; top: -5px">{{ ":" }}</text>
        <text class="time" style="left: 108px; top: -1px; transform: rotate(9deg)">
          {{ time[2] }}
        </text>
        <text class="time" style="left: 126.1px; top: 3.8px; transform: rotate(21deg)">
          {{ time[3] }}
        </text>
      </div>

      <!-- 内容区域 -->
      <div class="scene">
        <block for="{{segments}}">
          <text if="$item.type === 'text'" class="normal-text">
            {{ $item.content }}
          </text>
          <div if="$item.type === 'newline'" style="width: 100%"></div>
          <text if="$item.type === 'link'" class="link-text" onclick="selectOption($item.linkIndex)">
            {{ $item.content }}
          </text>
          <text if="$item.type === 'disabled'" class="disabled-text">
            {{ $item.content }}
          </text>
          <image if="$item.type === 'image'" src="{{$item.path}}" style="width:{{$item.width}}px" data-index="{{$idx}}"
            onerror="handleImageError" />
          <text if="$item.type === 'error'" class="error-text">
            [ERR] {{ $item.content }}
          </text>
        </block>
      </div>
    </scroll>
  </div>
</template>

<script>
import router from "@system.router";
import storage from "@system.storage";
import prompt from "@system.prompt";
import vibrator from "@system.vibrator";

import gameData from "../../common/game-data.json";

export default {
	private: {
    time: ['0','0','0','0'], // 新增时间数组初始化
		debugMode: false,
		timer: null,
		showMenu: false,
		activeTab: "status",
		saveSlots: [
			{ time: "" },
			{ time: "" },
			{ time: "" },
			{ time: "" },
			{ time: "" },
		],
		currentNodeId: "start",
		segments: [],
		currentLinks: [],
		STORAGE_KEY: "game_state",
		showVars: [],
		listeners: [], // 时间推进监听器
		vars: {}, // 变量系统
		hourChanged: false, // 时间推进标志
		dayChanged: false, // 天数变化标志
		currentNode: null, // 当前节点引用
	},
	protected:{
		loadSlot: null
	},

	// ================= 生命周期方法 =================
	onInit() {
		this.loadFromSlot(this.loadSlot);
		// 初始化游戏状态
		this.initVariableSystem();
		this.updateShowVars();
		this.loadNode(this.currentNodeId);
		this.loadSaveSlots();
		this.debugLog("游戏初始化完成");
	},

	onDestroy() {
		// 清理定时器
		clearInterval(this.timer);
	},

	onBackPress() {
		// 返回键处理
		this.toggleMenu();
		return true;
	},

  updateGameTime() {
  // 使用游戏内格式化时间
  const formattedTime = this.getFormattedTime();
  
  // 拆分小时和分钟
  const [hours, minutes] = formattedTime.split(":");
  
  // 更新弧形时间显示
  this.time = [
    hours[0],    // 小时十位
    hours[1],    // 小时个位 
    minutes[0], // 分钟十位
    minutes[1]  // 分钟个位
  ];
},

	// ================= UI交互方法 =================
	scrollTo() {
		// 滚动到顶部
		this.$element("scrollId").scrollTo({
			top: 0,
			left: 0,
		});
	},

	toggleMenu() {
		// 切换菜单显示状态
		this.showMenu = !this.showMenu;
		if (this.showMenu) {
			this.activeTab = "status";
			this.loadSaveSlots();
		}
	},

	switchTab(tabName) {
		// 切换菜单标签页
		this.activeTab = tabName;
	},

	backToHome() {
		// 返回首页
		router.replace({ uri: "pages/index" });
	},

	toggleDebugMode(e) {
		// 切换调试模式
		this.debugMode = e.checked;
		this.showToast(`调试模式 ${e.checked ? "开启" : "关闭"}`);
	},

	selectOption(linkIndex) {
		// 处理选项选择
		if (!this.validateLinkIndex(linkIndex)) {
			return this.showToast("无效选项");
		}

		const link = this.currentLinks[linkIndex];
		const jumpTriggered = this.executeActions(link.actions || []);

		if (!jumpTriggered) {
			let targetNode = this.processLinkTarget(link);
			if (link.incom) this.processIncomingData(link.incom);

			this.timer = setTimeout(() => {
				this.debugLog(`选择选项: ${linkIndex} -> ${targetNode}`);
				this.loadNode(targetNode);
			}, 150);
		}
	},

	handleImageError(e) {
		// 处理图片加载错误
		const index = parseInt(e.target.dataset.index);
		if (isNaN(index)) return;

		const segment = this.segments[index];
		if (segment?.type === "image") {
			this.pushErrorSegment(`图片加载失败: ${segment.path}`);
			this.$page.$forceUpdate();
		}
	},

	// ================= 核心引擎方法 =================
	loadNode(nodeId) {
		// 加载游戏节点
		try {
			const jumpTarget = this.beforeLoadNode(nodeId);
			if (jumpTarget) {
				this.debugLog(`监听器触发跳转: ${jumpTarget}`);
				this.loadNode(jumpTarget);
				return;
			}

			const node = gameData.nodes[nodeId];
			if (!node) throw new Error(`节点 ${nodeId} 未找到`);

			this.currentNode = node;
			this.currentNodeId = nodeId;
			this.currentLinks = node.links || [];
			this.executeActions(node.actions || []);
			this.parseTextWithLinks(node.text);

			this.debugLog(`加载节点: ${nodeId}`, {
				links: this.currentLinks.length,
			});
		} catch (e) {
			this.handleError("节点加载错误", e);
		}
    this.updateGameTime();
		this.scrollTo();
	},

	parseTextWithLinks(text) {
		// 解析带链接的文本
		this.segments = [];
		if (!text) return;

		let processedText = text.replace(
			/\{(var\.[^}]+|random\.[^}]+|cond\.[^}]+)\}/g,
			(_, path) => {
				if (path.startsWith("cond.")) {
					return `{${path}}`;
				}
				return this.resolveValue(path);
			}
		);

		let lastPosition = 0;
		const regex = /(\{\w+\.?[\w\.]*\}|\n)/g;
		let match;

		while ((match = regex.exec(processedText)) !== null) {
			if (match.index > lastPosition) {
				const preText = processedText.substring(lastPosition, match.index);
				if (preText) this.segments.push({ type: "text", content: preText });
			}

			const matched = match[1];
			if (matched === "\n") {
				this.segments.push({ type: "newline" });
			} else if (matched.startsWith("{cond.")) {
				const condPath = matched.replace(/\{|\}/g, "");
				const condValue = this.resolveCondition(condPath);

				const tempSegments = this.segments;
				this.segments = [];
				this.parseTextWithLinks(condValue);
				this.segments = tempSegments.concat(this.segments);
			} else if (matched.startsWith("{img")) {
				this.handleImageMarker(matched.replace(/\{|\}/g, ""));
			} else if (matched.startsWith("{js.")) {
				this.handleScriptMarker(matched.replace(/\{|\}/g, ""));
			} else if (/^\{\d+\}$/.test(matched)) {
				const linkId = parseInt(matched.replace(/\{|\}/g, ""));
				this.handleLinkMarker(linkId);
			} else {
				this.segments.push({ type: "text", content: matched });
			}

			lastPosition = match.index + matched.length;
		}

		if (lastPosition < processedText.length) {
			const remaining = processedText.substring(lastPosition);
			if (remaining) this.segments.push({ type: "text", content: remaining });
		}
	},

	resolveCondition(path) {
		// 解析条件标记
		const parts = path.split(".");
		if (parts[0] !== "cond") return `[无效条件标记: ${path}]`;

		const groupName = parts[1];
		const conditionGroup = this.currentNode?.conds?.[groupName];
		if (!conditionGroup) return `[条件组不存在: ${groupName}]`;

		for (const item of conditionGroup) {
			if (item.condition) {
				try {
					const conditionResult = this.parseExpression(item.condition);
					if (conditionResult) {
						return item.text || "";
					}
				} catch (e) {
					console.error(`条件解析失败: ${item.condition}`, e);
					return `[条件错误: ${item.condition}]`;
				}
			} else {
				return item.text || "";
			}
		}

		return `[无匹配条件: ${path}]`;
	},

	// ================= 变量系统 =================
	initVariableSystem() {
		// 初始化变量系统
		this.vars = JSON.parse(JSON.stringify(gameData.variables || {}));
		this.debugLog("变量系统初始化");
	},

	parseVariablePath(path) {
		// 解析变量路径
		if (!path.startsWith("var.")) {
			this.debugLog(`无效变量路径: ${path}`);
			return null;
		}
		return path.substring(4).split(".");
	},

	getVariable(path) {
		// 获取变量值
		const parts = path.split(".");
		if (parts[0] !== "var") return undefined;

		let value = this.vars;
		for (let i = 1; i < parts.length; i++) {
			if (value === null || value === undefined) return undefined;
			value = value[parts[i]];
		}

		return value;
	},

	setVariable(path, value) {
		// 设置变量值
		const parts = this.parseVariablePath(path);
		if (!parts) return;

		let current = this.vars;
		for (let i = 0; i < parts.length - 1; i++) {
			const part = parts[i];
			if (!current[part] || typeof current[part] !== "object") {
				current[part] = {};
			}
			current = current[part];
		}

		const lastKey = parts[parts.length - 1];
		current[lastKey] = this.resolveValue(value);
		this.debugLog(`变量设置: ${path} = ${JSON.stringify(current[lastKey])}`);
		this.updateShowVars();
	},

	updateShowVars() {
		// 更新显示变量
		const showVars = [];
		const showBranch = this.vars.show || {};

		Object.entries(showBranch).forEach(([key, config]) => {
			if (config && typeof config === "object") {
				showVars.push({
					desc: config.desc || key,
					value: config.value !== undefined ? config.value : "无数据",
				});
			}
		});

		this.showVars = showVars;
	},

	// ================= 值解析系统 =================
	resolveValue(input) {
		// 统一值解析
		if (typeof input !== "string") return input;

		if (input.startsWith("##") && input.endsWith("##")) {
			return input.slice(2, -2);
		}

		if (input.startsWith("$(") && input.endsWith(")")) {
			return this.parseExpression(input.slice(2, -1));
		}

		if (input.startsWith("var.")) {
			return this.getVariable(input);
		}

		if (input.startsWith("random.")) {
			const result = this.getRandomResult(input);
			return result?.text || result || `[随机错误: ${input}]`;
		}

		return input;
	},

	parseTextMarkers(text) {
		// 解析文本标记
		if (typeof text !== "string") return text;

		return text.replace(
			/\{(var\.[^}]+|random\.[^}]+|cond\.[^}]+)\}/g,
			(_, path) => {
				if (path.startsWith("cond.")) {
					return this.resolveCondition(path);
				}
				return this.resolveValue(path);
			}
		);
	},

	// ================= 表达式解析器 =================
	parseExpression(expr) {
		// 解析表达式
		try {
			const varPattern = /var\.([\w.]+)/g;
			let processedExpr = expr.replace(varPattern, (_, path) => {
				const value = this.getVariable(`var.${path}`);
				return typeof value === "number" ? value : JSON.stringify(value);
			});

			const context = {
				Math: Math,
				utils: this.expressionUtils || {},
				engine: this,
				var: this.vars,
			};

			return new Function(
				"context",
				`with(context){ return ${processedExpr}; }`
			).call(context, context);
		} catch (e) {
			this.debugLog(`表达式解析失败: ${expr}`, e);
			return false;
		}
	},

	// ================= 条件检查系统 =================
	checkCondition(condition) {
		// 检查条件是否满足
		if (condition === "hourChanged") return this.hourChanged;
		if (condition === "dayChanged") return this.dayChanged;
		if (!condition) return true;

		if (condition.startsWith("$(") && condition.endsWith(")")) {
			try {
				return !!this.parseExpression(condition.slice(2, -1));
			} catch (e) {
				console.error(`条件表达式错误: ${condition}`, e);
				return false;
			}
		}

		const andParts = condition.split("&&").map((s) => s.trim());
		if (andParts.length > 1)
			return andParts.every((p) => this.checkCondition(p));

		const orParts = condition.split("||").map((s) => s.trim());
		if (orParts.length > 1) return orParts.some((p) => this.checkCondition(p));

		const match = condition.match(
			/([\w.]+|'[^']*'|"[^"]*")\s*(==|!=|>|<|>=|<=)\s*(['"].*?['"]|[\w.]+)/
		);

		if (match) {
			let [, left, operator, right] = match;
			left = this.resolveValue(left);
			right = this.resolveValue(right);

			switch (operator) {
				case "==":
					return left == right;
				case "!=":
					return left != right;
				case ">":
					return left > right;
				case "<":
					return left < right;
				case ">=":
					return left >= right;
				case "<=":
					return left <= right;
			}
		}

		if (condition === "true") return true;
		if (condition === "false") return false;
		if (condition.startsWith("var.")) return !!this.getVariable(condition);

		return false;
	},

	// ================= 操作执行器 =================
	executeActions(actions = []) {
		// 执行动作序列
		let jumpTriggered = false;
		actions.forEach((action) => {
			try {
				switch (action.type) {
					case "set":
						this.setVariable(action.target, action.value);
						break;
					case "add":
						const current = this.getVariable(action.target) || 0;
						const addValue = this.resolveValue(action.value);
						const numValue =
							typeof addValue === "number"
								? addValue
								: !isNaN(addValue)
								? parseFloat(addValue)
								: 0;
						this.setVariable(action.target, current + numValue);
						break;
					case "toggle":
						const currentBool = this.getVariable(action.target) || false;
						this.setVariable(action.target, !currentBool);
						break;
					case "random":
						const result = this.getRandomResult(`random.${action.id}`);
						if (result?.actions) this.executeActions(result.actions);
						break;
					case "vibrate":
						if (vibrator?.vibrate)
							vibrator.vibrate({ mode: action.mode || "long" });
						break;
					case "autosave":
						this.saveToSlot(4);
						break;
					case "addListener":
						const options = {
							once: action.once !== false,
							nodeId: action.nodeId || null,
						};
						this.addListener(
							action.id,
							action.condition,
							action.actions || [],
							options
						);
						break;
					case "removeListener":
						if (action.id === "all") {
							this.listeners = [];
						} else {
							this.removeListener(action.id);
						}
						break;
					case "advanceTime":
						const minutes = this.resolveValue(action.minutes);
						if (typeof minutes === "number" && minutes > 0) {
							this.advanceTime(minutes);
						}
						break;
					case "toast":
						const rawMessage = action.message;
						const parsedMessage = this.parseTextMarkers(rawMessage);
						const finalMessage = this.resolveValue(parsedMessage);
						const displayMessage =
							typeof finalMessage === "string"
								? finalMessage
								: JSON.stringify(finalMessage);
						const duration = this.resolveValue(action.duration) || 2000;
						this.showToast(displayMessage, duration);
						break;
					case "jump":
						if (jumpTriggered) return;
						const targetNode = this.resolveValue(action.target);
						const condition = action.condition;
						if (!condition || this.checkCondition(condition)) {
							this.debugLog(`执行跳转操作: ${targetNode}`);
							if (action.beforeActions) {
								this.executeActions(action.beforeActions);
							}
							this.loadNode(targetNode);
							jumpTriggered = true;
							if (action.afterActions) {
								setTimeout(() => {
									this.executeActions(action.afterActions);
								}, 100);
							}
							return;
						}
						break;
				}
			} catch (e) {
				this.debugLog(`操作执行失败: ${JSON.stringify(action)}`, e);
			}
		});
		return jumpTriggered;
	},

	// ================= 标记处理器 =================
	handleLinkMarker(linkIndex) {
		// 处理链接标记
		if (!this.validateLinkIndex(linkIndex)) {
			return this.pushErrorSegment(`无效链接${linkIndex}`);
		}

		const link = this.currentLinks[linkIndex];
		const isActive = this.checkCondition(link.condition);

		this.segments.push({
			type: isActive ? "link" : "disabled",
			content: link.text,
			linkIndex,
		});
	},

	handleImageMarker(markerId) {
		// 处理图片标记
		const imgId = markerId.replace("img.", "");
		const currentNode = gameData.nodes[this.currentNodeId];

		if (!currentNode || !currentNode.imgs || !currentNode.imgs[imgId]) {
			return this.pushErrorSegment(`图片配置错误: ${imgId}`);
		}

		const imgDef = currentNode.imgs[imgId];
		let path = imgDef.path || "";

		if (path.includes("${")) {
			try {
				path = path.replace(
					/\${(.*?)}/g,
					(_, expr) => this.parseExpression(expr)?.toString() || ""
				);
			} catch (e) {
				return this.pushErrorSegment(`图片路径表达式错误: ${imgId}`);
			}
		}

		let finalPath = path;
		if (
			path &&
			!path.includes("/common/images/") &&
			!path.startsWith("/") &&
			!path.startsWith("http") &&
			!path.startsWith(".")
		) {
			finalPath = "/common/images/" + path;
		}

		this.segments.push({
			type: "image",
			path: finalPath,
			width: imgDef.width || 150,
		});
	},

	handleScriptMarker(marker) {
		// 处理脚本标记（待实现）
		this.debugLog(`脚本标记: ${marker}`);
	},

	getRandomResult(markerId) {
		// 获取随机结果
		const randomId = markerId.replace("random.", "");
		try {
			const randoms = gameData.nodes[this.currentNodeId]?.randoms;
			if (!randoms || !randoms[randomId]) {
				return `[ERROR]随机组未定义`;
			}

			const options = randoms[randomId];
			const validOptions = options.filter(
				(opt) => !opt.condition || this.checkCondition(opt.condition)
			);

			if (validOptions.length === 0) return "[无可用选项]";

			const totalWeight = validOptions.reduce(
				(sum, o) =>
					sum + (typeof o.weight === "number" ? Math.max(0, o.weight) : 1),
				0
			);

			if (totalWeight <= 0) return validOptions[0]?.text || "[权重错误]";

			let randomVal = Math.random() * totalWeight;
			for (const opt of validOptions) {
				randomVal -= opt.weight || 1;
				if (randomVal <= 0) return opt.text || opt;
			}

			return validOptions[0]?.text || "[随机错误]";
		} catch (e) {
			return `[ERROR]随机处理失败`;
		}
	},

	// ================= 监听器系统 =================
	addListener(id, condition, actions = [], options = {}) {
		// 添加监听器
		this.removeListener(id);
		this.listeners.push({
			id,
			condition,
			actions,
			once: options.once !== false,
			nodeId: options.nodeId || null,
			type: options.type || "general",
		});
		this.debugLog(`监听器添加: ${id}`);
	},

	removeListener(id) {
		// 移除监听器
		const newLength = this.listeners.filter((l) => l.id !== id).length;
		if (this.listeners.length !== newLength) {
			this.listeners = this.listeners.filter((l) => l.id !== id);
			this.debugLog(`监听器移除: ${id}`);
		}
	},

	advanceTime(minutes) {
		// 推进游戏时间
		if (typeof minutes !== "number" || minutes <= 0) return;

		const currentTime = this.getVariable("var.world.time");
		const currentDay = this.getVariable("var.world.day");
		let newTime = currentTime + minutes;
		let newDay = currentDay;

		let dayChanged = false;
		if (newTime >= 1440) {
			newDay += Math.floor(newTime / 1440);
			newTime = newTime % 1440;
			dayChanged = true;
		}

		let hourChanged = false;
		const currentHour = Math.floor(currentTime / 60);
		const newHour = Math.floor(newTime / 60);
		if (currentHour !== newHour) {
			hourChanged = true;
		}

		this.setVariable("var.world.time", newTime);
		this.setVariable("var.world.day", newDay);
		this.setVariable("var.world.formattedTime", this.formatGameTime(newTime));
    this.updateGameTime();

		this.hourChanged = hourChanged;
		this.dayChanged = dayChanged;
		this.checkAllListeners();
		this.hourChanged = false;
		this.dayChanged = false;
	},

	formatGameTime(minutes) {
		// 格式化游戏时间
		const hours = Math.floor(minutes / 60);
		const mins = minutes % 60;
		return `${hours.toString().padStart(2, "0")}:${mins
			.toString()
			.padStart(2, "0")}`;
	},

	checkAllListeners() {
		// 检查所有监听器
		const currentState = {
			time: this.getVariable("var.world.time") || 480,
			day: this.getVariable("var.world.day") || 1,
		};

		this.listeners.forEach((listener) => {
			try {
				if (this.checkCondition(listener.condition)) {
					this.executeActions(listener.actions);
					if (listener.once) {
						this.removeListener(listener.id);
					}
				}
			} catch (e) {
				this.debugLog(`监听器检查失败: ${listener.id}`, e);
			}
		});
	},

	beforeLoadNode() {
		// 节点加载前检查监听器
		let jumpTarget = null;
		const generalListeners = this.listeners.filter((l) => l.type !== "time");

		const jumpListener = generalListeners.find(
			(l) => l.nodeId && this.checkCondition(l.condition)
		);

		if (jumpListener) {
			this.executeActions(jumpListener.actions);
			jumpTarget = jumpListener.nodeId;
			if (jumpListener.once) {
				this.removeListener(jumpListener.id);
			}
			return jumpTarget;
		}

		generalListeners.forEach((listener) => {
			if (this.checkCondition(listener.condition)) {
				this.executeActions(listener.actions);
				if (listener.once) {
					this.removeListener(listener.id);
				}
			}
		});

		return null;
	},

	// ================= 存档系统 =================
	validateSlotIndex(index) {
		// 验证存档槽索引是否有效
		return index >= 0 && index < this.saveSlots.length;
	},

	getSlotKey(index) {
		// 获取存档槽对应的存储键名
		return `save_slot_${index}`;
	},

	saveGameState() {
		// 保存当前游戏状态（自动存档）
		const state = {
			vars: JSON.parse(JSON.stringify(this.vars)),
			currentNodeId: this.currentNodeId,
			listeners: JSON.parse(JSON.stringify(this.listeners)), // 保存监听器状态
		};

		storage.set({
			key: this.STORAGE_KEY,
			value: JSON.stringify(state),
			success: () => this.debugLog("游戏状态已保存"),
			fail: (data, code) => this.debugLog(`保存失败: code=${code}`),
		});
	},

	loadSaveSlots() {
		// 加载所有存档槽的元数据信息
		[0, 1, 2, 3, 4].forEach((slotIndex) => {
			storage.get({
				key: this.getSlotKey(slotIndex),
				success: (data) => {
					if (data) {
						try {
							const saveData = JSON.parse(data);
							this.saveSlots[slotIndex].time = saveData.time;
						} catch (e) {
							this.saveSlots[slotIndex].time = "损坏存档";
						}
					}
				},
			});
		});
	},

	saveToSlot(slotIndex) {
		// 保存游戏状态到指定存档槽
		if (!this.validateSlotIndex(slotIndex)) return;

		const saveData = {
			time: this.getCurrentDateTime(),
			state: {
				vars: JSON.parse(JSON.stringify(this.vars)),
				currentNodeId: this.currentNodeId,
				listeners: JSON.parse(JSON.stringify(this.listeners)), // 保存监听器状态
			},
		};

		storage.set({
			key: this.getSlotKey(slotIndex),
			value: JSON.stringify(saveData),
			success: () => {
				this.saveSlots[slotIndex] = saveData;
				this.showToast(`存档${slotIndex + 1}成功`, 1000);
			},
			fail: () => this.showToast("存档失败", 1000),
		});
	},

	loadFromSlot(slotIndex) {
		slotIndex = Number(slotIndex);
		// 从指定存档槽加载游戏状态
		if (!this.validateSlotIndex(slotIndex)) return;

		storage.get({
			key: this.getSlotKey(slotIndex),
			success: (data) => {
				if (data) {
					try {
						const saveData = JSON.parse(data);

						// 恢复游戏状态
						this.vars = saveData.state.vars || {};
						this.currentNodeId = saveData.state.currentNodeId || "start";
						this.listeners = saveData.state.listeners || []; // 恢复监听器状态

						// 更新UI状态
						this.updateShowVars();

						// 加载节点
						this.loadNode(this.currentNodeId);
						this.showToast(`加载存档${slotIndex + 1}成功`, 1000);
					} catch (e) {
						this.showToast("存档损坏", 1500);
					}
				} else {
					this.showToast("无存档数据", 1000);
				}
				this.showMenu = false;
			},
			fail: () => {
				this.showToast("加载失败", 1000);
				this.showMenu = false;
			},
		});
	},

	deleteSaveSlot(slotIndex) {
		// 删除指定存档槽
		if (!this.validateSlotIndex(slotIndex)) return;

		storage.delete({
			key: this.getSlotKey(slotIndex),
			success: () => {
				this.saveSlots[slotIndex].time = "";
				this.showToast(`删除存档${slotIndex + 1}成功`, 1000);
			},
			fail: () => this.showToast("删除失败", 1000),
		});
	},

	// ================= 辅助方法 =================
	validateLinkIndex(index) {
		// 验证链接索引
		return index >= 0 && index < this.currentLinks.length;
	},

	processLinkTarget(link) {
		// 处理链接目标
		let targetNode = link.target;

		if (link.random?.length > 0) {
			const validOptions = link.random.filter(
				(opt) => !opt.if || this.checkCondition(opt.if)
			);

			if (validOptions.length > 0) {
				const totalWeight = validOptions.reduce((sum, o) => sum + o.weight, 0);
				let randVal = Math.random() * totalWeight;

				for (const opt of validOptions) {
					randVal -= opt.weight;
					if (randVal <= 0) {
						targetNode = opt.target;
						if (opt.incom) this.processIncomingData(opt.incom);
						break;
					}
				}
			}
		}

		return targetNode;
	},

	processIncomingData(data) {
		// 处理传入数据
		Object.entries(data).forEach(([key, value]) => {
			try {
				const finalValue = this.resolveValue(value);
				this.setVariable(`var.temp.${key}`, finalValue);
			} catch (e) {
				this.setVariable(`var.temp.${key}`, value);
			}
		});
	},

	getCurrentTime() {
		// 获取当前时间
		const now = new Date();
		return `${now.getHours().toString().padStart(2, "0")}:${now
			.getMinutes()
			.toString()
			.padStart(2, "0")}`;
	},

	getCurrentDateTime() {
		// 获取当前日期时间
		const now = new Date();
		return (
			`${now.getFullYear()}-${(now.getMonth() + 1)
				.toString()
				.padStart(2, "0")}-${now.getDate().toString().padStart(2, "0")} ` +
			`${now.getHours().toString().padStart(2, "0")}:${now
				.getMinutes()
				.toString()
				.padStart(2, "0")}:${now.getSeconds().toString().padStart(2, "0")}`
		);
	},

	getFormattedTime() {
		// 获取格式化时间
		const timeVar = this.getVariable("var.world.time");
		if (typeof timeVar !== "number") {
			return timeVar || "08:00";
		}

		const normalizedTime = ((timeVar % 1440) + 1440) % 1440;
		const hours = Math.floor(normalizedTime / 60);
		const minutes = normalizedTime % 60;
		return `${hours.toString().padStart(2, "0")}:${minutes
			.toString()
			.padStart(2, "0")}`;
	},

	getFullTimeInfo() {
		// 获取完整时间信息
		const day = this.getVariable("var.world.day") || 1;
		const time = this.getVariable("var.world.time") || 480;

		return {
			day,
			time,
			formatted: this.getFormattedTime(),
			period: this.getTimePeriod(time),
		};
	},

	getTimePeriod(time) {
		// 获取时间段描述
		const hour = Math.floor(time / 60);

		if (hour < 5) return "深夜";
		if (hour < 8) return "凌晨";
		if (hour < 11) return "早晨";
		if (hour < 13) return "中午";
		if (hour < 17) return "下午";
		if (hour < 20) return "傍晚";
		return "夜晚";
	},

	// ================= 调试工具 =================
	debugLog(message, data = null) {
		// 调试日志
		if (this.debugMode) {
			console.info(`[DEBUG] ${message}`, data);
			this.showToast(`DEBUG: ${message}`, 100);
		}
	},

	showToast(message, duration = 2000) {
		// 显示提示
		prompt.showToast({ message, duration });
	},

	handleError(context, error) {
		// 错误处理
		const msg = `${context}: ${error.message || error}`;
		this.pushErrorSegment(msg);
		this.showToast(msg);
		console.error(context, error);
	},

	pushErrorSegment(message) {
		// 添加错误片段
		this.segments.push({
			type: "error",
			content: message,
		});
	},
};
</script>

<style>
/* 主容器 */
.main-container {
	width: 100%;
	height: 100%;
	position: relative;
}

.content-scroll {
	width: 100%;
	height: 100%;
	padding: 16px;
	background-color: #000;
	flex-direction: column;
}

/* 顶部区域 */
.header {
	width: 100%;
	height: 35px;
	flex-direction: column;
	align-items: center;
}

.time {
	position: absolute;
	width: 25px;
	height: 33px;
	font-size: 25px;
	font-weight: 600;
	line-height: normal;
	text-align: center;
	display: flex;
	align-items: flex-end;
	letter-spacing: normal;
	color: rgba(255, 255, 255, 0.6);
	transform-origin: 12.5px 16.5px;
}

.pagetitle {
	position: absolute;
	left: 0px;
	top: 35px;
	width: 212px;
	height: 42px;
	font-size: 32px;
	font-weight: 600;
	line-height: normal;
	text-align: center;
	letter-spacing: normal;
	color: rgba(255, 255, 255, 1);
}

.scene {
	width: 100%;
	padding: 10px;
	background-color: #1a1a1a;
	border-radius: 12px;
	flex-direction: row;
	flex-wrap: wrap;
	margin-top: 40px;
}

/* 文本样式 */
.normal-text {
	font-size: 26px;
	color: #fff;
}

.link-text {
	margin-top: 10px;
	font-size: 26px;
	color: #4a90e2;
	text-decoration: underline;
}

.disabled-text {
	font-size: 26px;
	color: #777;
	text-decoration: line-through;
}

.error-text {
	font-size: 26px;
	color: #ff4d4f;
}

/* 侧边栏菜单样式 */
.sidebar-menu {
	position: fixed;
	top: 0;
	right: 0;
	width: 192px;
	height: 100%;
	flex-direction: column;
	background-color: #222;
	z-index: 1000;
}

.menu-header {
	justify-content: center;
	align-items: center;
	padding: 10px 20px;
	background-color: #2a2a2a;
}

.menu-title {
	font-size: 30px;
	color: #fff;
}

.menu-close {
	width: 45px;
	height: 45px;
	color: #fff;
	background-color: #262626;
	border: 3px solid #333333;
	border-radius: 50%;
	padding: 0 10px;
}

.menu-tabs {
	flex-direction: row;
	height: 50px;
	width: 100%;
	background-color: #2a2a2a;
}

.menu-tab {
	flex: 1;
	height: 50px;
	text-align: center;
	line-height: 50px;
	font-size: 24px;
	color: #fff;
	background-color: #2a2a2a;
}

.active-tab {
	background-color: #333;
	color: #4a90e2;
}

/* 标签页内容容器 */
.tab-content-container {
	flex: 1;
	flex-direction: column;
}

.menu-scroll {
	flex: 1;
	padding: 10px;
	flex-direction: column;
}

/* 状态页样式 */
.status-section {
	flex-direction: row;
	justify-content: space-between;
	padding: 12px 0;
}

.status-label {
	font-size: 24px;
	color: #ccc;
}

.status-value {
	font-size: 24px;
	color: #fff;
}

/* 存档页样式 */
.save-section {
	flex-direction: column;
	padding: 5px;
}

.save-item {
	flex-direction: column;
	padding: 6px;
	width: 168px;
	margin-bottom: 10px;
	background-color: #252525;
	border-radius: 4px;
}

.save-header {
	flex-direction: column;
	justify-content: space-between;
	padding: 0 10px;
	margin-bottom: 8px;
}

.save-title {
	font-size: 24px;
	color: #fff;
}

.save-time {
	flex-direction: column;
}

.save-date {
	font-size: 18px;
	color: #999;
}

.save-time-part {
	font-size: 18px;
	color: #999;
}

.save-actions {
	flex-direction: row;
	justify-content: center;
}

.save-btn,
.load-btn .delete-btn {
	padding: 4px 8px;
	border-radius: 4px;
	font-size: 24px;
	color: #fff;
}

.save-btn {
	background-color: #2ecc71;
	margin-right: 10px;
}

.load-btn {
	background-color: #3498db;
}

.delete-btn {
	background-color: #e74c3c;
	margin-left: 10px;
}

/* 设置页样式 */
.settings-section {
	flex: 1;
	flex-direction: column;
	padding: 15px;
}

.setting-item {
	flex-direction: row;
	justify-content: space-between;
	align-items: center;
	padding: 15px 0;
}

.menu-action {
	margin-top: 20px;
	padding: 15px;
	background-color: #e74c3c;
	border-radius: 6px;
	text-align: center;
}
</style>